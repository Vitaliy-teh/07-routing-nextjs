Створено репозиторій 05-notehub
При здачі роботи надаються два посилання: на вихідні файли (репозиторій) та на робочу сторінку завдання, розгорнуту на Vercel.
Проєкт створено за допомогою Vite.
Під час запуску коду в консолі не повинно бути помилок або попереджень.
Для кожного компонента у папці src/components має бути окрема папка, яка містить файл самого React компонента та файл його стилів. Назва папки, файлу компонента (з розширенням .tsx) та файлу стилів (перед .module.css) однакова і відповідає назвам, вказаним у завданнях (якщо вони були).

У кожній папці компонента мають бути:
Файл компонента з розширенням .tsx (наприклад, App.tsx);
Файл стилів, назва якого закінчується на .module.css, з такою самою назвою (наприклад, App.module.css).

Для експорту компонентів використовується експорт за замовчуванням (export default).
Загальні типи, які використовуються в кількох компонентах, винесені в окремий файл (src/types/note.ts). Типи та інтерфейси, які стосуються лише одного компонента, оголошені безпосередньо у файлі цього компонента.
Для типізації пропсів компонентів використовується interface.
Інтерфейс для пропсів компонента називається за схемою: Ім’яКомпонентаProps (наприклад, UserCardProps).
Всі події в колбеках компонентів мають бути типізовані.
Для виконання HTTP-запитів використовується бібліотека axios.
TypeScript-код має бути чистим, зрозумілим і відформатованим за допомогою Prettier.
Стилізація виконується за допомогою CSS-модулів.
Використовується modern-normalize для уніфікації стилів у різних браузерах.

Додаток NoteHub

Створіть застосунок для зберігання, створення, видалення та пошуку нотаток. Подивіться демо-відео роботи застосунку.

Бекенд

Для роботи з колекцією нотаток використовуйте готовий бекенд. Документація до нього доступна за посиланням:

https://notehub-public.goit.study/api/docs

Щоб працювати з бекендом, вам потрібно отримати персональний ключ доступу прив’язаний до вашої пошти. Це буде зручно зробити прямо в документації бекенда.

З міркувань безпеки не зберігайте токен безпосередньо в коді. Замість цього використовуйте змінну оточення, наприклад: VITE_NOTEHUB_TOKEN.

При роботі з колекцією нотаток бекенд очікує, що токен передаватиметься в заголовку Authorization у форматі рядка:

"Bearer ваш_токен"

Після створення токену до вашої персональної колекції буде автоматично додано 40 тестових нотаток, щоб ви могли одразу працювати з готовими даними та не витрачати час на створення їх вручну.

Структура коду

Ознайомтесь з документацією бекенда. Він має маршрути для отримання списку нотаток та роботі з ними (створення, видалення тощо).

Створіть та винесіть інтерфейс Note для типізації однієї нотатки у файл src/types/note.ts і використовуйте його у компонентах.

Функції для виконання HTTP-запитів винесіть в окремий файл src/services/noteService.ts. Типізуйте їх параметри, результат, який вони повертають, та відповідь від Axios. У вас мають бути наступні функції:

fetchNotes : має виконувати запит для отримання колекції нотаток із сервера. Повинна підтримувати пагінацію (через параметр сторінки) та фільтрацію за ключовим словом (пошук);
createNote: має виконувати запит для створення нової нотатки на сервері. Приймає вміст нової нотатки та повертає створену нотатку у відповіді;
deleteNote: має виконувати запит для видалення нотатки за заданим ідентифікатором. Приймає ID нотатки та повертає інформацію про видалену нотатку у відповіді.

Типізація

Загальні інтерфейси, які пов’язані з сутністю нотаток (Note, NoteTag) мають бути у файлі — src/types/note.ts.

Інтерфейси, які описують відповіді http-запитів (FetchNotesResponse і т.д.) та параметри функцій, які виконують http-запити у — src/services/noteService.ts.

Інтерфейси, які описують пропси компонентів у — файлах відповідних компонентів.

Компоненти

У цьому завданні вам потрібно самостійно створити та реалізувати логіку наступних компонентів:

App – контейнер додатка
NoteList – колекція нотаток
Modal – універсальний компонент модального вікна, який може відображати будь-який вміст, переданий через children
NoteForm – форма створення нотатки
Pagination – елемент управління пагінацією
SearchBox – текстове поле для пошуку по колекції

Стилі для всіх компонентів вже створені. Скопіюй їх із цього репозиторію: https://github.com/goitacademy/react-notehub-styles. Після створення своїх компонентів скопіюй відповідні .module.css файли у відповідні папки в src/components.

Контейнер додатка

Компонент App є контейнером для решти компонентів і поки що створює таку розмітку:

<div className={css.app}>
	<header className={css.toolbar}>
		{/* Компонент SearchBox */}
		{/* Пагінація */}
		{/* Кнопка створення нотатки */}
  </header>
</div>

В майбутному в хедері буде додаткова розмітка елементів пошуку, пагінації та відкриття модального вікна для створення нотатки.

Колекція нотаток

При першому завантаженні додатка користувачу потрібно відображати список його власних нотаток.

Компонент NoteList – це список нотаток, додай його в App під хедером. Компонент NoteList має створювати DOM-елемент наступної структури:

<ul className={css.list}>
	{/* Набір елементів списку нотаток */}
  <li className={css.listItem}>
    <h2 className={css.title}>Note title</h2>
    <p className={css.content}>Note content</p>
    <div className={css.footer}>
      <span className={css.tag}>Note tag</span>
      <button className={css.button}>Delete</button>
    </div>
  </li>
</ul>

Для отримання списку нотаток з бекенда, всіх інших запитах по роботі з колекцією нотаток та збереження серверних даних використовуйте TanStack Query.

Додайте умову, щоб компонент NoteList рендерився лише в тому випадку, якщо в колекції нотаток є хоча б один елемент.

Пагінація

Бекенд завжди повертає пагіновану колекцію нотаток. Тому потрібно додати до компонента App компонент Pagination, який надає користувачеві можливість перемикатися між сторінками колекції. Реалізуйте компонент Pagination з використанням бібліотеки React Paginate.

До http-запиту потрібно додати параметри page та perPage. Наприклад:

GET https://notehub-public.goit.study/api/notes?page=1&perPage=12

Додайте умову, щоб компонент Pagination рендерився лише в тому випадку, якщо кількість сторінок колекції нотаток більше 1.

Створення нової нотатки

Додайте в хедер застосунку кнопку для створення нової нотатки:

<button className={css.button}>Create note +</button>

При натисканні на цю кнопку має відкриватись модальне вікно Modal з формою NoteForm. Компонент Modal має створювати DOM-елемент наступної структури:

<div
  className={css.backdrop}
  role="dialog"
  aria-modal="true"
>
  <div className={css.modal}>
    {/* */}
  </div>
</div>

Модальне вікно має створюватись через createPortal, щоб рендерити модалку поза межами основного дерева компонентів, та закриватися при кліку на бекдроп і натисканням на клавішу Escape.

Компонент NoteForm має створювати DOM-елемент наступної структури:

<form className={css.form}>
  <div className={css.formGroup}>
    <label htmlFor="title">Title</label>
    <input id="title" type="text" name="title" className={css.input} />
    <span name="title" className={css.error} />
  </div>

  <div className={css.formGroup}>
    <label htmlFor="content">Content</label>
    <textarea
      id="content"
      name="content"
      rows={8}
      className={css.textarea}
    />
    <span name="content" className={css.error} />
  </div>

  <div className={css.formGroup}>
    <label htmlFor="tag">Tag</label>
    <select id="tag" name="tag" className={css.select}>
      <option value="Todo">Todo</option>
      <option value="Work">Work</option>
      <option value="Personal">Personal</option>
      <option value="Meeting">Meeting</option>
      <option value="Shopping">Shopping</option>
    </select>
    <span name="tag" className={css.error} />
  </div>

  <div className={css.actions}>
    <button type="button" className={css.cancelButton}>
      Cancel
    </button>
    <button
      type="submit"
      className={css.submitButton}
      disabled=false
    >
      Create note
    </button>
  </div>
</form>

Для керування станом форми, валідації та обробки сабміту слід використовувати бібліотеку Formik.

Додай валідацію значень полів форми за допомогою Yup:

заголовок нотатки має мати мінімальну довжину символів 3, максимальну – 50 та бути обовязковим полем;
контент нотатки має мати максимальну довжину символів 500;
тег нотатки має бути одним із таких значень: Todo, Work, Personal, Meeting, Shopping, і є обов’язковим полем.

Видалення нотатки

При натисканні на кнопку Delete в елементі списку нотаток, відповідна нотатка має видалятися на бекенді та оновлюватись збережені серверні дані.

Пошук

Додайте в хедер застосунку компонент SearchBox. Він має створювати DOM-елемент наступної структури:

<input
  className={css.input}
  type="text"
  placeholder="Search notes"
 />

Користувач може шукати нотатки за допомогою текстового поля, при зміні значення якого на бекенд відправляється запит для отримання нотаток, які підходять під пошук. Для цього до запиту потрібно додати параметр search із текстовим значенням для пошуку:



GET https://notehub-public.goit.study/api/notes?search=mysearchtext

Обов’язково зробіть відкладений пошук з use-debounce, щоб не виконувати запит на кожний введений символ. Хук useDebounce варто використовувати саме в Арр і передавати відкладене пошукове слово у залежності в useQuery.

Додатково

Рекомендуємо створити окремі компоненти для відображення індикатора завантаження під час виконання HTTP-запитів, повідомлень про помилки та інших статусів запиту.

Завдання 1

Завдання вирішено правильно (файл src/types/note.ts)

Добре виконані аспекти:

Інтерфейс Note коректно визначений з усіма необхідними властивостями та відповідними типами.
Властивість tag використовує union type (NoteTag), який точно відображає дозволені значення тегів.
Код лаконічний, зрозумілий і не містить сторонніх або зайвих типів.
Фінальне рішення:

Завдання прийнято

Завдання 2

Завдання вирішено правильно (файл src/services/noteService.ts)

Добре виконані аспекти:

Усі запити axios використовують явні дженерик типи, що забезпечує типобезпечність.
Тип Note коректно імпортовано, а не оголошено локально.
Авторизація обробляється глобально через axios defaults, що гарантує включення необхідного заголовка до всіх запитів.
Типи запитів і відповідей чітко визначені та використовуються відповідно.
Функції асинхронні й повертають коректно типізовані проміси.
Функції fetch, create та delete відповідають очікуваним патернам взаємодії з API й повертають коректні дані.
Фінальне рішення:

Завдання прийнято

Завдання 3

Завдання вирішено правильно (файл src/components/NoteForm/NoteForm.tsx)

Добре реалізовані аспекти:

Усі поля форми (title, content, tag) присутні та коректно імплементовані, включаючи використання textarea для content та випадаючого списку select для tag.
Валідація виконується за допомогою Yup з правильними правилами для кожного поля.
Для керування станом форми та інтеграції валідації використовується Formik.
TanStack Query useMutation та useQueryClient коректно використовуються для створення нотатки та інвалідації запитів.
Усі пропси й змінні коректно типізовані, без використання any або неявного any.
Фінальне рішення:

Завдання прийнято

Завдання 4

Завдання вирішено правильно (файл src/components/NoteList/NoteList.tsx)

Добре реалізовані аспекти:

Всі необхідні поля нотатки (title, content, tag) відображаються для кожної нотатки.
Компонент коректно використовує useMutation та useQueryClient з TanStack Query для видалення та інвалідації кешу.
Пропси типізовані через інтерфейс NoteListProps, використовується імпортований тип Note.
Всі змінні та параметри функцій коректно типізовані, без використання any або неявного any.
Фінальне рішення:

Завдання було прийнято

Завдання 5

Завдання вирішено правильно (файл src/components/Modal/Modal.tsx)

Добре виконані аспекти:

Всі пропси явно та коректно типізовані, включаючи children як ReactNode.
Модальне вікно рендериться з використанням createPortal у document.body.
Натискання клавіші Escape закриває модальне вікно через коректно типізований обробник події.
Прокрутка сторінки вимикається при відкритті модального вікна та відновлюється при розмонтуванні.
Кліки по бекдропу закривають модальне вікно, у той час як кліки всередині контенту модального вікна — ні.
Відсутнє використання any або неявних типів any.
Фінальне рішення:

Завдання прийнято

Завдання 6

Завдання вирішено правильно (файл src/components/Pagination/Pagination.tsx)

Добре виконані аспекти:

Усі пропси чітко типізовані за допомогою інтерфейсу PaginationProps.
Компонент коректно передає необхідні пропси (pageCount, onPageChange, forcePage) у ReactPaginate.
По всьому коду використана правильна типізація TypeScript, без використання any або неявного any.
У компоненті додано захисний вираз, щоб уникати рендеру, коли пагінація не потрібна.
Остаточне рішення:

Завдання прийнято

Завдання 7

Завдання вирішено правильно (файл src/components/SearchBox/SearchBox.tsx)

Добре виконані аспекти:

Компонент правильно названий SearchBox і експортований згідно з вимогами.
Пропси типізовані через інтерфейс SearchBoxProps, що забезпечує типобезпечність.
Колбек onChange коректно типізований і викликається із значенням інпуту.
Усі змінні та параметри функцій явно типізовані, жодного використання any немає.
Фінальне рішення:

Завдання прийнято

Завдання 8

Завдання вирішено правильно (файл src/components/App/App.tsx)

Добре виконані аспекти:

Коректне використання debounce-пошукового запиту з useDebounce, що гарантує виклик завантаження даних лише після затримки debounce.
Належне керування станом для номера сторінки, пошукового запиту та статусу відкриття/закриття модального вікна.
Точне використання TanStack Query useQuery з необхідною структурою queryKey та placeholderData для плавної пагінації.
Усі змінні та параметри функцій мають правильні типи, без використання any або неявного any.
Умовний рендер компонентів (SearchBox, Pagination, Modal, NoteList) реалізовано коректно.
Фінальне рішення:

Завдання прийнято

Завдання 9

Завдання вирішено правильно (файл src/main.tsx)

Добре виконані аспекти:

І QueryClient, і QueryClientProvider коректно імпортовані з @tanstack/react-query.
Створено екземпляр QueryClient.
Кореневий компонент правильно обгорнуто в QueryClientProvider, і екземпляр queryClient передано як проп client.
Код чистий і добре структурований.
Фінальне рішення:

Завдання прийнято