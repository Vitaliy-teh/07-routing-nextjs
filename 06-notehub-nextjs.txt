Створено репозиторій 06-notehub-nextjs.
При здачі роботи надаються два посилання: на вихідні файли (репозиторій) та на робочу сторінку завдання, розгорнуту на Vercel.
Проєкт створено за допомогою Next.js (App Router).
Усі компоненти, які не прив'язані безпосередньо до маршруту та їх частин, зберігаються в папці components, кожен – у власній папці з такою ж назвою як і компонент, та з файлами:
1) файл компонента з розширенням .tsx (наприклад, Header.tsx);

2) файл стилів з такою самою назвою, що й компонент, з розширенням .module.css (наприклад, Header.module.css).

Загальні типи та інтерфейси винесені до файлу types/note.ts.
Функції роботи з API винесені в lib/api/ у вигляді окремих модулів.
Для HTTP-запитів використовується бібліотека axios.
Стан запитів у CSR-компонентах керується через TanStack Query (React Query).
Усі компоненти типізовані з використанням TypeScript.
Код має бути відформатований за допомогою Prettier.
Стилізація – за допомогою CSS Modules.
У проєкті реалізована підтримка SSR та CSR, відповідно до завдання.


Додаток NoteHub



У вас уже є додаток NoteHub, створений у попередньому (5-му) домашньому завданні. Тепер вам потрібно виконати його рефакторинг, зробити його багатосторінковим і перенести проєкт на Next.js.



Структура сторінок



У попередній версії NoteHub був односторінковим додатком (SPA). Тепер потрібно реалізувати багатосторінкову структуру з використанням маршрутизації Next.js. У додатку мають бути реалізовані такі маршрути:

/ – головна сторінка з загальною інформацією про застосунок.
/notes – сторінка списку нотатків. На цій сторінці відображається перелік усіх створених нотаток. Реалізовано функцію пошуку за ключовим словом, а також можливість створення нової нотатки.
/notes/[id] – сторінка деталей однієї нотатки (динамічний маршрут). На цій сторінці відображається повна інформація про одну нотатку за її id.


Головна сторінка



Додайте на головну сторінку вашого додатка загальну інформацію про нього:



<main>
  <div className={css.container}>
    <h1 className={css.title}>Welcome to NoteHub</h1>
    <p className={css.description}>
      NoteHub is a simple and efficient application designed for managing
      personal notes. It helps keep your thoughts organized and accessible
      in one place, whether you are at home or on the go.
    </p>
    <p className={css.description}>
      The app provides a clean interface for writing, editing, and browsing
      notes. With support for keyword search and structured organization,
      NoteHub offers a streamlined experience for anyone who values clarity
      and productivity.
    </p>
  </div>
</main>



Стилі для всіх компонентів і сторінок вже створені. Скопіюй їх із цього репозиторію: https://github.com/goitacademy/react-notehub-styles/tree/hw-06. Після створення своїх сторінок і компонентів скопіюй відповідні .module.css файли у відповідні папки в /app.


Глобальний Layout



Усі сторінки вашого додатка мають мати спільний хедер і футер.



Створи для цього компоненти:

Header – має містити навігацію з лінками на сторінки Home та Notes.
Footer – має містити контактну інформацію розробника застосунку.


Компонент Header має створювати наступну розмітку. Для створення посилань в навігації використовуй готовий компонент від Next.js.



<header className={css.header}>
  <a href="/" aria-label="Home">
    NoteHub
  </a>
  <nav aria-label="Main Navigation">
    <ul className={css.navigation}>
      <li>
        <a href="/">Home</a>
      </li>
      <li>
        <a href="/notes">Notes</a>
      </li>
    </ul>
  </nav>
</header>



Компонент Footer має створювати наступну розмітку:



<footer className={css.footer}>
  <div className={css.content}>
    <p>© {new Date().getFullYear()} NoteHub. All rights reserved.</p>
    <div className={css.wrap}>
      <p>Developer: your name</p>
      <p>
        Contact us:
        <a href="mailto:student@notehub.app">student@notehub.app</a>
      </p>
    </div>
  </div>
</footer>



API-запити



Весь вміст файлу src/services/noteService.ts з попередньої ДЗ перенесіть у файл lib/api.ts.



Зверніть увагу, що env змінні в Next.js отримуються дещо інакше ніж було в Vite і є вимога щодо назви env змінної. Змінна має починатись з NEXT_PUBLIC, тому перейменуйте її на NEXT_PUBLIC_NOTEHUB_TOKEN. Також для отримання значення цієї змінної вам потрібно замість import.meta.env.VITE_NOTEHUB_TOKEN використовувати process.env.NEXT_PUBLIC_NOTEHUB_TOKEN.



Не забудьте також перенести в проєкт файл types/note.ts.



Сторінка списку нотатків



Весь вміст компонента App з попередньої ДЗ перенесіть на сторінку /notes. Усі інші компоненти з попередньої ДЗ перенесіть у папку components.



Реалізуйте сторінковий компонент Notes у маршруті /notes як SSR-компонент, де заздалегідь виконується prefetch (попереднє завантаження даних через TanStack Query) з гідратацією кешу. Усю клієнтську логіку (отримання списку нотаток за допомогою useQuery та їх відображення) винесіть в окремий файл компонента app/notes/Notes.client.tsx.



Обробка помилок і завантаження



Реалізуйте обробку стану завантаження у файлі loading.tsx. Буде достатньо створити один файл для всіх маршрутів і реалізувати у ньому створення наступної розмітки:



<p>Loading, please wait...</p>



Реалізуйте обробку помилок для маршруту /notes у файлі error.tsx. Буде достатньо в ньому створити наступну розмітку, описавши суть помилки:



<p>Could not fetch the list of notes. {error.message}</p>



Для перевірки, що опрацювання помилки працює коректно можете штучно створити помилку, додавши будь-який зайвий символ у вашу env змінну NEXT_PUBLIC_NOTEHUB_TOKEN.



Сторінка з деталями однієї нотатки



Внесіть зміну у розмітку компонента NoteList. Додайте на картку однієї нотатки перед кнопкою Delete посилання View details. Це посилання буде вести на сторінку з деталями конкретної нотатки.



Створіть динамічний маршрут для сторінки з деталями однієї нотатки за її id.

У файлі lib\api.ts створіть функцію fetchNoteById для отримання деталей однієї нотатки за її ідентифікатором.



Реалізуйте сторінковий компонент NoteDetails у маршруті /notes/[id] як SSR-компонент, де заздалегідь виконується prefetch (попереднє завантаження даних через TanStack Query) з гідратацією кешу. Усю клієнтську логіку (отримання даних нотатки за допомогою useQuery та їх відображення) винесіть в окремий файл компонента app/notes/NoteDetails.client.tsx.



Для отримання динамічного id в клієнтському компоненті використовуйте хук useParams().



Не забудьте про TanStackProvider:

Створіть в components\TanStackProvider\TanStackProvider.tsx компонент, який додає QueryClientProvider.
Підключіть його глобально в app/layout.tsx, щоб забезпечити правильну роботу кешування та роботи з запитами через TanStack Query в усіх компонентах вашого додатка.


Обов‘язково у клієнтському компоненті NoteDetailsClient опрацюйте стани isLoading, error та випадок коли детальну інформацію по нотатці не було отримано в клієнтському компоненті NoteDetailsClient. Поки що буде достатньо повернути наступну розмітку:



// isLoading
<p>Loading, please wait...</p>

// error, !note
<p>Something went wrong.</p>;



Якщо нотатку за переданим айді було знайдено, то компонент NoteDetailsClient має створювати наступну розмітку:



<div className={css.container}>
	<div className={css.item}>
	  <div className={css.header}>
	    <h2>Note title</h2>
	  </div>
	  <p className={css.content}>Note content</p>
	  <p className={css.date}>Created date</p>
	</div>
</div>



Реалізуйте обробку помилок для маршруту /notes/[id] у файлі error.tsx. Буде достатньо в ньому створити наступну розмітку, описавши суть помилки:



<p>Could not fetch note details. {error.message}</p>

Завдання 1

Завдання вирішено правильно (файл types/note.ts)

Добре виконані аспекти:

Інтерфейс Note коректно визначений з усіма необхідними властивостями та відповідними типами.
Властивість tag використовує union type (NoteTag), що точно відображає дозволені значення тегів.
Код лаконічний, зрозумілий і не містить сторонніх або надлишкових типів.
Фінальне рішення:

Завдання прийнято

Завдання 2

Завдання вирішено правильно (файл lib/api.ts)

Добре виконані аспекти:

Усі функції для API реалізовані як асинхронні функції з використанням axios.
Заголовок авторизації встановлюється глобально з використанням токена з відповідної змінної оточення.
Для всіх запитів axios явно вказані дженерики, що гарантує типобезпеку.
Тип Note імпортується, а не оголошується локально.
Визначені й використовуються відповідні інтерфейси TypeScript для даних запиту та відповіді.
Для всіх функцій явно зазначено тип повернення, який відповідає відповіді API.
Код чистий, добре структурований та легкий для читання.
Остаточне рішення:

Завдання прийнято

Завдання 3

Завдання вирішено правильно (файл app/layout.tsx)

Добре виконані аспекти:

Компонент RootLayout коректно реалізований як експорт за замовчуванням.
Макет містить необхідні теги <html> та <body>.
TanStackProvider обгортає Header, children і Footer відповідно до вимог.
Проп children правильно типізований як React.ReactNode.
Компоненти Header і Footer розташовані відповідно у верхній та нижній частині.
Глобальні стилі імпортуються належним чином.
Метадані визначені згідно з актуальними конвенціями Next.js.
Фінальне рішення:

Завдання прийнято

Завдання 4

Завдання вирішено правильно (файл app/page.tsx)

Добре виконані аспекти:

Компонент реалізовано у page.tsx і використано структуру функціонального компонента.
Семантичні HTML-елементи, такі як <main>, <h1> та <p>, використані доречно для передачі структури та змісту контенту.
Основна інформація про застосунок чітко представлена.
Для стилізації застосовуються CSS Modules, що свідчить про гарний поділ відповідальностей.
Остаточне рішення:

Завдання прийнято

Завдання 5

Завдання вирішено правильно (файл app/loading.tsx)

Добре виконані аспекти:

Файл loading.tsx правильно розташований у директорії app.
Компонент коректно визначений як дефолтний експорт.
Індикатор завантаження надає чіткий зворотний зв’язок користувачу під час Стану завантаження.
Код синтаксично правильний і використовує TypeScript/JSX відповідним чином.
Фінальне рішення:

Завдання прийнято

Завдання 6

Завдання вирішено правильно (файл app/notes/page.tsx)

Добре виконані аспекти:

Компонент коректно реалізований як серверний компонент.
Дані нотаток попередньо отримуються на сервері за допомогою методу React Query prefetchQuery.
queryKey правильно структурований як масив із рядковим ключем.
queryFn коректно викликає функцію fetchNotes з явними параметрами.
Попередньо отримані дані передаються клієнтському компоненту через HydrationBoundary та dehydrate.
Відсутнє використання any або неявного any; типобезпечність дотримана.
Клієнтський компонент відображається відповідно до вимог.
Фінальне рішення:

Завдання прийнято

Завдання 7

Завдання вирішено правильно (файл app/notes/Notes.client.tsx)

Добре виконані аспекти:

Коректне використання дебаунсеного пошукового запиту з useDebounce та правильний ресет номера сторінки при зміні пошукового запиту.
Належне управління станом для номера сторінки, пошукового запиту і статусу відкриття/закриття модального вікна.
Точне використання useQuery з ключем запиту, який включає як сторінку, так і дебаунсений пошуковий запит, та використання placeholderData для запобігання мерехтінню UI.
Умовний рендеринг Modal, NoteForm, Pagination та NoteList на основі відповідного стану й даних.
Усі змінні та параметри функцій належно типізовані, без використання any або неявного any.
Остаточне рішення:

Завдання було прийнято

Завдання 8

Завдання вирішено правильно (файл app/notes/error.tsx)

Добре виконані аспекти:

Компонент коректно позначений як Client Component за допомогою директиви "use client".
Компонент експортується як default export.
Проп error правильно типізований як об'єкт Error.
Повідомлення про помилку відображається та включає значення error.message.
Остаточне рішення:

Завдання прийнято

Завдання 9

Завдання вирішено правильно (файл app/notes/[id]/page.tsx)

Добре виконані аспекти:

Серверний компонент коректно очікує на проміс params та витягує id.
Дані нотатки префетчаться на сервері за допомогою queryClient.prefetchQuery з відповідним queryKey та queryFn.
Префетчені дані надаються клієнтському компоненту через HydrationBoundary та dehydrate.
Проп params коректно типізовано як Promise<{ id: string }> і не використовується any.
Клієнтський компонент рендериться з правильним пропом id.
Фінальне рішення:

Завдання прийнято

Завдання 10

Завдання вирішено правильно (файл app/notes/[id]/NoteDetails.client.tsx)

Добре виконані аспекти:

Директива "use client" коректно розміщена на початку файлу, що гарантує, що компонент є клієнтським компонентом.
Хук useQuery використовується з queryKey, який містить як рядок, так і id, а queryFn коректно отримує нотатку за її id.
Опція refetchOnMount явно встановлена у значення false.
Стан завантаження та помилки обробляються належним чином.
Деталі нотатки відображаються лише у разі наявності отриманих даних.
Всі пропси явно типізовані, і немає використання any або неявного any.
Фінальне рішення:

Завдання прийнято

Завдання 11

Завдання вирішено правильно (файл app/notes/[id]/error.tsx)

Добрe виконані аспекти:

Компонент правильно позначено як Client Component за допомогою директиви "use client".
Проп error коректно типізовано як об'єкт Error.
Повідомлення про помилку відображається та містить error.message.
Компонент використовує дефолтний експорт згідно з вимогами.
Фінальне рішення:

Завдання прийнято

Завдання 12

Завдання вирішено правильно (файл components/TanStackProvider/TanStackProvider.tsx)

Добре виконані аспекти:

Директива "use client" правильно розміщена на початку файлу, що гарантує, що компонент є клієнтським компонентом.
Проп children явно типізований як ReactNode.
Єдина інстанція QueryClient ініціалізується за допомогою стану React.
QueryClientProvider коректно обгортає проп children.
Код є типобезпечним і не використовує any чи неявний any.
Додаткові пропозиції:

Додавання ReactQueryDevtools є корисним для розробки, хоча і не є обов'язковим.
Фінальне рішення:

Завдання прийнято

Завдання 13

Завдання вирішено правильно (файл components/Header/Header.tsx)

Добре виконані аспекти:

Компонент використовує семантичні HTML-елементи (<header>, <nav>, <ul>, <li>).
Навігаційні посилання реалізовано за допомогою компонента Link з next/link.
Навігація охоплює як домашню сторінку, так і сторінку нотаток.
Не використовується any або неявний тип any; збережено типобезпечність.
Компонент структурований для повторного використання та зрозумілості.
Фінальне рішення:

Завдання прийнято

Завдання 14

Завдання вирішено правильно (файл components/Footer/Footer.tsx)

Добре виконані аспекти:

Компонент коректно використовує семантичні HTML-елементи (<footer>, <div>, <p>, <a>).
TypeScript використовується без застосування any або неявного any.
Компонент структурований та читабельний.
Динамічне відображення року реалізовано правильно.
Відсутній зайвий або невикористаний код.
Фінальне рішення:

Завдання прийнято

Завдання 15

Завдання вирішено правильно (файл components/NoteForm/NoteForm.tsx)

Добре виконані аспекти:

Усі поля форми (title, content, tag) присутні та коректно реалізовані, включаючи використання textarea для content і select dropdown для tag.
Валідація здійснюється за допомогою Yup з відповідними правилами для кожного поля.
Для керування станом форми використовується Formik, який інтегрується з валідацією на основі Yup.
Мутація для створення нотатки реалізована з використанням TanStack Query useMutation, з коректною інвалідацією запиту нотаток і закриттям форми після успішної дії.
Усі пропси і змінні типізовані належним чином, не використовується any чи неявний any.
Фінальне рішення:

Завдання прийнято

Завдання 16

Завдання вирішено правильно (файл components/NoteList/NoteList.tsx)

Добре виконані аспекти:

Для кожної нотатки відображаються всі обов’язкові поля (title, content, tag).
Функціонал видалення реалізований за допомогою useMutation з TanStack Query із коректною інвалідацією кешу через queryClient.invalidateQueries.
Для кожної нотатки передбачено Link на детальну сторінку з правильним шляхом /notes/{id}.
Пропси компонента типізовані через інтерфейс NoteListProps, усі змінні та параметри функцій коректно типізовані.
Фінальне рішення:

Завдання прийнято

Завдання 17

Завдання вирішено правильно (файл components/Modal/Modal.tsx)

Добре виконані аспекти:

Усі пропси явно та коректно типізовані, включаючи children як ReactNode.
Модалка рендериться за допомогою createPortal у document.body.
Модалка закривається натисканням клавіші Escape через коректно типізований обробник події.
Прокрутка сторінки вимикається при відкритій модалці та відновлюється після розмонтування.
Захист контенту модалки від кліків по бекдропу реалізовано шляхом зупинки поширення події у внутрішньому контейнері.
Не використовується any або неявні типи any.
Остаточне рішення:

Завдання прийнято

Завдання 18

Завдання вирішено правильно (файл components/Pagination/Pagination.tsx)

Добре виконані аспекти:

Усі пропси строго типізовані за допомогою інтерфейсу PaginationProps.
Компонент ReactPaginate використовується з обов’язковими пропсами (pageCount, onPageChange, forcePage).
Колбек-функція для зміни сторінки коректно типізована та передана далі.
Компонент не рендериться, коли пагінація не потрібна (нуль або одна сторінка).
Фінальне рішення:

Завдання прийнято

Завдання 19

Завдання вирішено правильно (файл components/SearchBox/SearchBox.tsx)

Добре виконані аспекти:

Компонент коректно названо SearchBox та експортовано згідно з вимогами.
Пропси типізовані через інтерфейс з назвою SearchBoxProps, і всі типи явно задані без використання any.
Колбек onChange правильно типізовано та викликається зі значенням інпуту.
Компонент лаконічний, зрозумілий і відповідає найкращим практикам React та TypeScript.
Остаточне рішення:

Завдання прийнято